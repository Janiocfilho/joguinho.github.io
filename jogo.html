<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jogo Sprite Pixelado com Joystick 8 direções</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: #000;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background: #222;
      image-rendering: pixelated;
    }
    #joystick {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 140px;
      height: 140px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 50%;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }
    #stick {
      width: 70px;
      height: 70px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      position: absolute;
      left: 35px;
      top: 35px;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }
  </style>
  <!-- PeerJS -->
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>
<body>
  <canvas id="game" width="160" height="144"></canvas>
  <div id="joystick">
    <div id="stick"></div>
  </div>

  <!-- PreloadJS -->
  <script src="https://code.createjs.com/1.0.0/preloadjs.min.js"></script>
  <!-- GSAP -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <script>
  
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    // Escala para deixar pixel perfeito ao redimensionar
    const scale = 4;
    canvas.style.width = canvas.width * scale + "px";
    canvas.style.height = canvas.height * scale + "px";

    // Desliga suavização para pixel art nítido
    ctx.imageSmoothingEnabled = false;

    const spriteSize = 16;
    const frameCols = 2;
    const tiles3D = [
      { x: 40, y: 60, width: 16, height: 16, z: 24 }, // exemplo de uma caixa ou parede
      { x: 80, y: 100, width: 16, height: 16, z: 40 }, // objeto mais alto
    ];
  
    // Player objeto
    const player = {
      x: canvas.width / 2 - spriteSize / 2,
      y: canvas.height / 2 - spriteSize / 2,
      dir: "down",
      frame: 0,
      frameDelay: 0,
      moving: false,
      speed: 1,
    };

    // Armazena sprites carregadas
    const sprites = {};

    // Direções possíveis para 8 direções
    const directions = [
      "up",
      "down",
      "left",
      "right",
      "diagup-left",
      "diagup-right",
      "diagdown-left",
      "diagdown-right",
    ];

    // Controle das teclas
    let keys = { up: false, down: false, left: false, right: false };
    let peer, conn;
let isHost = false;
let otherPlayer = { x: 0, y: 0, dir: "down", frame: 0, moving: false };

// ID baseado no IP local genérico
const basePeerID = "game-peer";

// Tenta se conectar a um host existente
function initNetwork() {
  // Cria peer com ID temporário (cliente)
  const tempPeer = new Peer();

  tempPeer.on("open", (id) => {
    conn = tempPeer.connect(basePeerID);

    // Se conectar com sucesso, é cliente
    conn.on("open", () => {
      console.log("Conectado ao host.");
      setupConnectionEvents();
    });

    // Se falhar, se torna o host
    conn.on("error", () => {
      console.log("Falha ao conectar. Este será o host.");
      startAsHost();
    });

    // Se não responder em 2s, torna-se host
    setTimeout(() => {
      if (!conn.open) {
        console.log("Sem resposta. Tornando-se host.");
        startAsHost();
      }
    }, 2000);
  });
}

function startAsHost() {
  isHost = true;
  peer = new Peer(basePeerID);

  peer.on("open", () => {
    console.log("Host iniciado.");
  });

  peer.on("connection", (connection) => {
    conn = connection;
    setupConnectionEvents();
    console.log("Cliente conectado.");
  });
}

function setupConnectionEvents() {
  conn.on("data", (data) => {
    if (!isHost) {
      // Cliente recebe posição do host
      otherPlayer = data;
    } else {
      // Host recebe do cliente e responde com seu estado
      otherPlayer = data;
      conn.send({
        x: player.x,
        y: player.y,
        dir: player.dir,
        frame: player.frame,
        moving: player.moving,
      });
    }
  });
}

// Envia estado atual ao outro jogador
function sendState() {
  if (conn && conn.open) {
    const data = {
      x: player.x,
      y: player.y,
      dir: player.dir,
      frame: player.frame,
      moving: player.moving,
    };
    conn.send(data);
  }
}

initNetwork(); // Inicia a rede assim que o script carrega
    // Função para decidir a direção do player com base nas teclas pressionadas
    function getDirection() {
      if (keys.up && keys.left) return "diagup-left";
      if (keys.up && keys.right) return "diagup-right";
      if (keys.down && keys.left) return "diagdown-left";
      if (keys.down && keys.right) return "diagdown-right";
      if (keys.up) return "up";
      if (keys.down) return "down";
      if (keys.left) return "left";
      if (keys.right) return "right";
      return player.dir; // manter a última direção
    }
    
    // Atualiza posição do player
    function update() {
      player.moving = false;
      let dx = 0,
        dy = 0;

      if (keys.up) dy -= 1;
      if (keys.down) dy += 1;
      if (keys.left) dx -= 1;
      if (keys.right) dx += 1;

      if (dx !== 0 || dy !== 0) {
        // normalizar movimento diagonal para manter velocidade constante
        const len = Math.sqrt(dx * dx + dy * dy);
        dx = (dx / len) * player.speed;
        dy = (dy / len) * player.speed;

        // Atualiza posição arredondando para inteiro (grade de pixels)
        player.x = Math.round(player.x + dx);
        player.y = Math.round(player.y + dy);

        player.moving = true;
        player.dir = getDirection();
      }

      // Atualiza animação
      if (player.moving) {
        player.frameDelay++;
        if (player.frameDelay >= 10) {
          player.frame = (player.frame + 1) % 4;
          player.frameDelay = 0;
        }
      } else {
        player.frame = 0;
      }
    }

    // Desenha player na tela
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      let img;
      let flip = false;

      switch (player.dir) {
        case "up":
          img = sprites.up;
          break;
        case "down":
          img = sprites.down;
          break;
        case "left":
          img = sprites.side;
          break;
        case "right":
          img = sprites.side;
          flip = true;
          break;
        case "diagup-left":
          img = sprites.diagup;
          break;
        case "diagup-right":
          img = sprites.diagup;
          flip = true;
          break;
        case "diagdown-left":
          img = sprites.diagdown;
          flip = true;
          break;
        case "diagdown-right":
          img = sprites.diagdown;
          break;
      }
      
      
function drawOtherPlayer() {
  if (!sprites.down) return;

  let img;
  let flip = false;

  switch (otherPlayer.dir) {
    case "up":
      img = sprites.up;
      break;
    case "down":
      img = sprites.down;
      break;
    case "left":
      img = sprites.side;
      break;
    case "right":
      img = sprites.side;
      flip = true;
      break;
    case "diagup-left":
      img = sprites.diagup;
      break;
    case "diagup-right":
      img = sprites.diagup;
      flip = true;
      break;
    case "diagdown-left":
      img = sprites.diagdown;
      flip = true;
      break;
    case "diagdown-right":
      img = sprites.diagdown;
      break;
  }

  const col = otherPlayer.frame % frameCols;
  const row = Math.floor(otherPlayer.frame / frameCols);

  const px = Math.round(otherPlayer.x);
  const py = Math.round(otherPlayer.y);

  ctx.save();
  if (flip) {
    ctx.translate(px + spriteSize, py);
    ctx.scale(-1, 1);
  } else {
    ctx.translate(px, py);
  }
  ctx.drawImage(
    img,
    col * spriteSize,
    row * spriteSize,
    spriteSize,
    spriteSize,
    0,
    0,
    spriteSize,
    spriteSize
  );
  ctx.restore();
}
      
      const col = player.frame % frameCols;
      const row = Math.floor(player.frame / frameCols);

      const px = Math.round(player.x);
      const py = Math.round(player.y);

      ctx.save();
      if (flip) {
        ctx.translate(px + spriteSize, py);
        ctx.scale(-1, 1);
      } else {
        ctx.translate(px, py);
      }
      ctx.drawImage(
        img,
        col * spriteSize,
        row * spriteSize,
        spriteSize,
        spriteSize,
        0,
        0,
        spriteSize,
        spriteSize
      );
      ctx.restore();
    }
  
    function drawOtherPlayer() {
  if (!sprites.down) return;

  let img;
  let flip = false;

  switch (otherPlayer.dir) {
    case "up":
      img = sprites.up;
      break;
    case "down":
      img = sprites.down;
      break;
    case "left":
      img = sprites.side;
      break;
    case "right":
      img = sprites.side;
      flip = true;
      break;
    case "diagup-left":
      img = sprites.diagup;
      break;
    case "diagup-right":
      img = sprites.diagup;
      flip = true;
      break;
    case "diagdown-left":
      img = sprites.diagdown;
      flip = true;
      break;
    case "diagdown-right":
      img = sprites.diagdown;
      break;
  }

  const col = otherPlayer.frame % frameCols;
  const row = Math.floor(otherPlayer.frame / frameCols);

  const px = Math.round(otherPlayer.x);
  const py = Math.round(otherPlayer.y);

  ctx.save();
  if (flip) {
    ctx.translate(px + spriteSize, py);
    ctx.scale(-1, 1);
  } else {
    ctx.translate(px, py);
  }
  ctx.drawImage(
    img,
    col * spriteSize,
    row * spriteSize,
    spriteSize,
    spriteSize,
    0,
    0,
    spriteSize,
    spriteSize
  );
  ctx.restore();
}
    function gameLoop() {
  update();
  draw();
  sendState(); // envia estado para o outro jogador
  drawOtherPlayer(); // desenha o outro jogador
  requestAnimationFrame(gameLoop);
}

    // Setup joystick
    const joystick = document.getElementById("joystick");
    const stick = document.getElementById("stick");

    // Limite máximo para movimentação do stick (raio)
    const maxDistance = 50;

    // Armazenar estado do joystick
    let joyX = 0;
    let joyY = 0;

    // Função para quantizar joystick em passos discretos (ex: passos de 10px)
    function quantize(value, step = 10) {
      if (value > 0) return Math.min(maxDistance, Math.floor(value / step) * step);
      if (value < 0) return Math.max(-maxDistance, Math.ceil(value / step) * step);
      return 0;
    }

    joystick.addEventListener(
      "touchstart",
      (e) => {
        e.preventDefault();
      },
      { passive: false }
    );

    joystick.addEventListener(
      "touchmove",
      (e) => {
        const touch = e.touches[0];
        const rect = joystick.getBoundingClientRect();
        let x = touch.clientX - rect.left - rect.width / 2;
        let y = touch.clientY - rect.top - rect.height / 2;

        // Limita o joystick dentro do círculo (raio maxDistance)
        const dist = Math.sqrt(x * x + y * y);
        if (dist > maxDistance) {
          const angle = Math.atan2(y, x);
          x = Math.cos(angle) * maxDistance;
          y = Math.sin(angle) * maxDistance;
        }

        // Quantiza para evitar flutuações pequenas
        joyX = quantize(x);
        joyY = quantize(y);

        // Usa GSAP para suavizar o movimento do stick visualmente
        gsap.to(stick, {
          x: joyX,
          y: joyY,
          duration: 0.05,
          ease: "power2.out",
        });

        // Atualiza teclas baseadas no joystick quantizado
        keys.left = joyX < -10;
        keys.right = joyX > 10;
        keys.up = joyY < -10;
        keys.down = joyY > 10;
      },
      { passive: false }
    );

    joystick.addEventListener("touchend", () => {
      // Reseta joystick e teclas
      joyX = 0;
      joyY = 0;
      keys = { up: false, down: false, left: false, right: false };

      gsap.to(stick, {
        x: 0,
        y: 0,
        duration: 0.2,
        ease: "power3.out",
      });
    });

    // Controles de teclado (opcional)
    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowUp") keys.up = true;
      if (e.key === "ArrowDown") keys.down = true;
      if (e.key === "ArrowLeft") keys.left = true;
      if (e.key === "ArrowRight") keys.right = true;
    });
    window.addEventListener("keyup", (e) => {
      if (e.key === "ArrowUp") keys.up = false;
      if (e.key === "ArrowDown") keys.down = false;
      if (e.key === "ArrowLeft") keys.left = false;
      if (e.key === "ArrowRight") keys.right = false;
    });

    // PreloadJS para carregar imagens
    const loader = new createjs.LoadQueue(false);
    loader.loadManifest([
      { id: "down", src: "https://i.imgur.com/Y6wqpnF.png" },
      { id: "up", src: "https://i.imgur.com/PuoBPF2.png" },
      { id: "side", src: "https://i.imgur.com/KHTustA.png" },
      { id: "diagup", src: "https://i.imgur.com/H2DJtsG.png" },
      { id: "diagdown", src: "https://i.imgur.com/HmJ1YQH.png" },
    ]);

    loader.on("complete", () => {
      sprites.down = loader.getResult("down");
      sprites.up = loader.getResult("up");
      sprites.side = loader.getResult("side");
      sprites.diagup = loader.getResult("diagup");
      sprites.diagdown = loader.getResult("diagdown");

      gameLoop();
    });
  </script>
</body>
</html>
